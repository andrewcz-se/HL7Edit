<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HL7 v2.x Message Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --hl7-segment: #6366f1; /* indigo-500 */
            --hl7-field: #22c55e; /* green-500 */
            --hl7-component: #f97316; /* orange-500 */
            --hl7-subcomponent: #3b82f6; /* blue-500 */
            --hl7-repetition: #a855f7; /* purple-500 */
            --hl7-escape: #ef4444; /* red-500 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }

        .font-mono {
            font-family: 'Fira Code', monospace;
        }
        
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e2e8f0; /* slate-200 */
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
        
        .hl7-tooltip {
            position: relative;
            display: inline-block;
        }

        .hl7-tooltip .tooltiptext {
            visibility: hidden;
            width: max-content;
            background-color: #1e293b; /* slate-800 */
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        
        .hl7-tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1e293b transparent transparent transparent;
        }

        .hl7-tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Highlighting styles */
        .segment.highlight, .field.highlight, .component.highlight, .subcomponent.highlight, .repetition-item.highlight {
            background-color: #fef9c3; /* yellow-100 */
            outline: 1px solid #facc15; /* yellow-400 */
            transition: background-color 0.1s ease-in-out;
        }

        .segment.selected, .field.selected, .component.selected, .subcomponent.selected, .repetition-item.selected {
            background-color: #dbeafe; /* blue-100 */
            outline: 2px solid #3b82f6; /* blue-500 */
            font-weight: 500;
        }
        
        .drag-over {
            border-style: dashed;
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }

        #rawViewDisplay .raw-field.selected {
            background-color: #dbeafe; /* blue-100 */
        }
         #rawViewDisplay .raw-field:hover {
            background-color: #fef9c3; /* yellow-100 */
            cursor: pointer;
        }

    </style>
</head>
<body class="text-slate-800">
    <div class="flex flex-col h-screen">
        <!-- Header -->
        <header class="bg-white border-b border-slate-200 p-3 flex items-center justify-between shadow-sm flex-shrink-0">
            <div class="flex items-center space-x-3">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-indigo-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                <h1 class="text-xl font-semibold text-slate-700">HL7 v2.x Message Editor</h1>
            </div>
            <div class="flex items-center space-x-2">
                <button id="openFileBtn" class="px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 text-sm font-medium">Open File</button>
                <input type="file" id="fileInput" accept=".hl7,.txt" class="hidden">
                <button id="exportBtn" class="px-4 py-2 bg-slate-600 text-white rounded-md hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500 text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed">Export to HL7</button>
                <button id="clearBtn" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400 text-sm font-medium">Clear</button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-grow flex flex-col lg:flex-row gap-4 p-4 min-h-0">
            <!-- Left: Raw Input -->
            <div class="w-full lg:w-5/12 flex flex-col">
                <div class="flex-shrink-0 mb-2 flex items-center justify-between">
                    <h2 class="text-lg font-medium text-slate-600">Raw HL7 Input</h2>
                 </div>
                <div id="dropZone" class="flex-grow bg-white border-2 border-slate-300 rounded-lg shadow-sm p-1 transition-all relative">
                    <textarea id="hl7Input" class="w-full h-full font-mono text-sm border-0 rounded-md resize-none focus:ring-0" placeholder="Paste or drop an HL7 message here..."></textarea>
                    <div id="rawViewDisplay" class="w-full h-full font-mono text-sm absolute top-0 left-0 p-2.5 hidden overflow-auto whitespace-pre"></div>
                </div>
            </div>

            <!-- Middle: Structured View -->
            <div class="w-full lg:w-4/12 flex flex-col">
                <h2 class="flex-shrink-0 text-lg font-medium text-slate-600 mb-2">Structured View</h2>
                <div id="structuredView" class="flex-grow bg-white border-2 border-slate-300 rounded-lg shadow-sm p-4 overflow-auto min-h-0">
                    <div id="placeholder" class="text-slate-400 h-full flex items-center justify-center">
                        Parse a message to see the structured view.
                    </div>
                </div>
            </div>
            
            <!-- Right: Details Panel -->
            <div class="w-full lg:w-3/12 flex flex-col">
                <h2 class="flex-shrink-0 text-lg font-medium text-slate-600 mb-2">Details</h2>
                <div id="detailsPanel" class="flex-grow bg-white border-2 border-slate-300 rounded-lg shadow-sm p-4 overflow-auto min-h-0">
                    <div id="detailsPlaceholder" class="text-slate-400 h-full flex items-center justify-center">
                        Select an element to see details.
                    </div>
                     <div id="detailsContent" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-slate-500">Path</label>
                            <p id="detailPath" class="font-mono text-sm bg-slate-100 p-2 rounded-md text-indigo-700"></p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-500">Description</label>
                            <p id="detailDescription" class="text-sm text-slate-700"></p>
                        </div>
                        <div>
                            <label for="detailValue" class="block text-sm font-medium text-slate-500">Value</label>
                            <textarea id="detailValue" rows="2" class="w-full font-mono text-sm border border-slate-300 rounded-md p-2 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button id="applyChangesBtn" class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed" disabled>Apply</button>
                            <button id="undoChangesBtn" class="w-full px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed" disabled>Undo</button>
                        </div>
                        <div id="componentsContainer" class="hidden">
                            <label class="block text-sm font-medium text-slate-500">Components</label>
                            <div id="componentsList" class="space-y-1 mt-1"></div>
                        </div>
                        <div id="subcomponentsContainer" class="hidden">
                             <label class="block text-sm font-medium text-slate-500">Sub-components</label>
                             <div id="subcomponentsList" class="space-y-1 mt-1"></div>
                        </div>
                     </div>
                </div>
            </div>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const hl7Input = document.getElementById('hl7Input');
        const exportBtn = document.getElementById('exportBtn');
        const clearBtn = document.getElementById('clearBtn');
        const openFileBtn = document.getElementById('openFileBtn');
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const rawViewDisplay = document.getElementById('rawViewDisplay');
        const structuredView = document.getElementById('structuredView');
        const placeholder = document.getElementById('placeholder');
        const detailsPanel = document.getElementById('detailsPanel');
        const detailsPlaceholder = document.getElementById('detailsPlaceholder');
        const detailsContent = document.getElementById('detailsContent');
        const detailPath = document.getElementById('detailPath');
        const detailDescription = document.getElementById('detailDescription');
        const detailValue = document.getElementById('detailValue');
        const componentsContainer = document.getElementById('componentsContainer');
        const componentsList = document.getElementById('componentsList');
        const subcomponentsContainer = document.getElementById('subcomponentsContainer');
        const subcomponentsList = document.getElementById('subcomponentsList');
        const applyChangesBtn = document.getElementById('applyChangesBtn');
        const undoChangesBtn = document.getElementById('undoChangesBtn');

        // --- State Management ---
        let parsedMessage = null;
        let selectedElement = null;
        let hl7Dictionary = {};
        let originalFieldValue = null;

        // --- HL7 Data Dictionary (simplified) ---
        const loadDictionary = async () => {
            // In a real app, this would be fetched from a server or a larger local file.
            hl7Dictionary = {
                "MSH": { "desc": "Message Header", "fields": {
                    "1": "Field Separator", "2": "Encoding Characters", "3": "Sending Application", "4": "Sending Facility",
                    "5": "Receiving Application", "6": "Receiving Facility", "7": "Date/Time of Message", "8": "Security",
                    "9": "Message Type", "10": "Message Control ID", "11": "Processing ID", "12": "Version ID"
                }},
                "PID": { "desc": "Patient Identification", "fields": {
                    "1": "Set ID - PID", "2": "Patient ID", "3": "Patient Identifier List", "4": "Alternate Patient ID - PID",
                    "5": "Patient Name", "6": "Mother's Maiden Name", "7": "Date/Time of Birth", "8": "Administrative Sex",
                    "10": "Race", "11": "Patient Address", "13": "Phone Number - Home"
                }},
                "PV1": { "desc": "Patient Visit", "fields": {
                    "1": "Set ID - PV1", "2": "Patient Class", "3": "Assigned Patient Location", "7": "Attending Doctor",
                    "19": "Visit Number", "44": "Admit Date/Time"
                }},
                "ORC": { "desc": "Common Order", "fields": {
                    "1": "Order Control", "2": "Placer Order Number", "3": "Filler Order Number", "9": "Date/Time of Transaction"
                }},
                "OBR": { "desc": "Observation Request", "fields": {
                    "1": "Set ID - OBR", "4": "Universal Service Identifier", "7": "Observation Date/Time", "16": "Ordering Provider"
                }},
                "OBX": { "desc": "Observation/Result", "fields": {
                    "1": "Set ID - OBX", "2": "Value Type", "3": "Observation Identifier", "4": "Observation Sub-ID",
                    "5": "Observation Value", "6": "Units", "7": "References Range", "8": "Abnormal Flags",
                    "11": "Observation Result Status", "14": "Date/Time of the Observation"
                }}
            };
        };

        // --- Parsing Logic ---
        const parseHL7 = (message) => {
            if (!message || !message.startsWith('MSH')) {
                // Silently fail for auto-parsing, don't show alert
                if (message.trim() !== '') {
                    console.error('Invalid HL7 message. Must start with MSH segment.');
                }
                return null;
            }
            message = message.replace(/[\r\n]+/g, '\r').trim();

            const fieldSep = message[3];
            const encodingChars = message.substring(4, 8);
            const componentSep = encodingChars[0];
            const repetitionSep = encodingChars[1];
            const escapeChar = encodingChars[2];
            const subcomponentSep = encodingChars[3];
            
            const delimiters = { fieldSep, componentSep, repetitionSep, escapeChar, subcomponentSep };
            
            const segments = message.split('\r');
            
            return {
                delimiters,
                segments: segments.map((segStr, segIndex) => {
                    const fields = segStr.split(fieldSep);
                    const segmentName = fields[0];
                    return {
                        name: segmentName,
                        fields: fields.map((fieldStr, fieldIndex) => {
                            if (segmentName === 'MSH' && fieldIndex === 1) return { value: encodingChars }; // Special handling for MSH-2
                            if (fieldIndex === 0) return { value: segmentName };

                            const repetitions = fieldStr.split(repetitionSep);
                            return {
                                value: fieldStr,
                                repetitions: repetitions.map((repStr, repIndex) => {
                                    const components = repStr.split(componentSep);
                                    return {
                                        value: repStr,
                                        components: components.map((compStr, compIndex) => {
                                            const subcomponents = compStr.split(subcomponentSep);
                                            return {
                                                value: compStr,
                                                subcomponents: subcomponents.map((subcompStr, subcompIndex) => ({
                                                    value: subcompStr
                                                }))
                                            };
                                        })
                                    };
                                })
                            };
                        })
                    };
                })
            };
        };
        
        // --- Rendering Logic ---
        const renderRawView = () => {
            if (!parsedMessage) return;

            rawViewDisplay.innerHTML = '';
            const { fieldSep } = parsedMessage.delimiters;

            parsedMessage.segments.forEach((segment, segIndex) => {
                const lineDiv = document.createElement('div');
                
                segment.fields.forEach((field, fIndex) => {
                    const fieldSpan = document.createElement('span');
                    if (fIndex > 0) { // Don't make segment name clickable as a field
                        fieldSpan.className = 'raw-field rounded px-0.5';
                        fieldSpan.dataset.segIndex = segIndex;
                        fieldSpan.dataset.fieldIndex = fIndex;
                    }
                    fieldSpan.textContent = field.value;
                    lineDiv.appendChild(fieldSpan);

                    if (fIndex < segment.fields.length - 1) {
                        const sepSpan = document.createElement('span');
                        sepSpan.textContent = fieldSep;
                        sepSpan.style.color = 'var(--hl7-field)';
                        lineDiv.appendChild(sepSpan);
                    }
                });
                rawViewDisplay.appendChild(lineDiv);
            });

            hl7Input.classList.add('hidden');
            rawViewDisplay.classList.remove('hidden');
        };

        const renderStructuredView = () => {
            if (!parsedMessage) {
                structuredView.innerHTML = '';
                placeholder.classList.remove('hidden');
                return;
            }
            placeholder.classList.add('hidden');
            structuredView.innerHTML = '';

            parsedMessage.segments.forEach((segment, segIndex) => {
                const segDiv = document.createElement('div');
                segDiv.className = 'segment mb-2';
                segDiv.dataset.segIndex = segIndex;

                const segHeader = document.createElement('div');
                segHeader.className = 'segment-name font-bold text-sm mb-1 cursor-pointer';
                segHeader.style.color = 'var(--hl7-segment)';

                const segmentInfo = hl7Dictionary[segment.name] || { desc: "Unknown Segment" };
                segHeader.innerHTML = `<span class="hl7-tooltip">${segment.name}<span class="tooltiptext">${segment.name} - ${segmentInfo.desc}</span></span>`;
                segDiv.appendChild(segHeader);

                const fieldsContainer = document.createElement('div');
                fieldsContainer.className = 'pl-2 border-l border-slate-200 ml-1 space-y-1';
                
                segment.fields.slice(1).forEach((field, fIndex) => {
                    const fieldIndex = fIndex + 1;
                    if (!field.value) return;

                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'field rounded text-xs flex items-start gap-2 py-0.5 px-1';
                    fieldDiv.dataset.segIndex = segIndex;
                    fieldDiv.dataset.fieldIndex = fieldIndex;

                    const fieldInfo = (segmentInfo.fields && segmentInfo.fields[fieldIndex]) || "Unknown Field";

                    const fieldLabel = document.createElement('div');
                    fieldLabel.className = 'field-label font-medium text-slate-500 whitespace-nowrap w-20';
                    fieldLabel.innerHTML = `<span class="hl7-tooltip">${segment.name}-${fieldIndex}<span class="tooltiptext">${fieldInfo}</span></span>`;
                    fieldDiv.appendChild(fieldLabel);

                    const fieldValue = document.createElement('div');
                    fieldValue.className = 'field-value font-mono break-all w-full';

                    if (field.repetitions && field.repetitions.length > 1) {
                         field.repetitions.forEach((rep, repIndex) => {
                             const repSpan = document.createElement('span');
                             repSpan.className = 'repetition-item block border-l-2 pl-2 my-1';
                             repSpan.style.borderColor = 'var(--hl7-repetition)';
                             repSpan.dataset.repIndex = repIndex;
                             renderComplexField(rep, repSpan, segIndex, fieldIndex, repIndex);
                             if (repIndex < field.repetitions.length - 1) {
                                const tilde = document.createElement('span');
                                tilde.textContent = ' ~';
                                tilde.style.color = 'var(--hl7-repetition)';
                                repSpan.appendChild(tilde);
                            }
                             fieldValue.appendChild(repSpan);
                         });
                    } else if (field.repetitions && field.repetitions.length === 1) {
                        renderComplexField(field.repetitions[0], fieldValue, segIndex, fieldIndex, 0);
                    } else if (field.hasOwnProperty('value')) {
                        // This case handles fields that were parsed into a simple {value: ...} object,
                        // like MSH-2, which don't have the full repetitions/components structure.
                        const subSpan = document.createElement('span');
                        subSpan.className = 'subcomponent inline-block cursor-pointer hover:bg-yellow-100';
                        subSpan.textContent = field.value;
                        subSpan.dataset.segIndex = segIndex;
                        subSpan.dataset.fieldIndex = fieldIndex;
                        subSpan.dataset.repIndex = 0;
                        subSpan.dataset.compIndex = 0;
                        subSpan.dataset.subcompIndex = 0;
                        fieldValue.appendChild(subSpan);
                    }

                    fieldDiv.appendChild(fieldValue);
                    fieldsContainer.appendChild(fieldDiv);
                });
                
                segDiv.appendChild(fieldsContainer);
                structuredView.appendChild(segDiv);
            });
        };
        
        const renderComplexField = (data, parentElement, segIndex, fieldIndex, repIndex) => {
            if (data.components.length > 1) {
                data.components.forEach((comp, compIndex) => {
                    renderComponent(comp, parentElement, segIndex, fieldIndex, repIndex, compIndex);
                    if (compIndex < data.components.length - 1) {
                        const sep = document.createElement('span');
                        sep.textContent = ' ^ ';
                        sep.style.color = 'var(--hl7-component)';
                        parentElement.appendChild(sep);
                    }
                });
            } else {
                 renderComponent(data.components[0], parentElement, segIndex, fieldIndex, repIndex, 0);
            }
        }
        
        const renderComponent = (comp, parentElement, segIndex, fieldIndex, repIndex, compIndex) => {
             const compSpan = document.createElement('span');
             compSpan.className = 'component inline-block';
             compSpan.dataset.segIndex = segIndex;
             compSpan.dataset.fieldIndex = fieldIndex;
             compSpan.dataset.repIndex = repIndex;
             compSpan.dataset.compIndex = compIndex;
             
             if (comp.subcomponents.length > 1) {
                 comp.subcomponents.forEach((sub, subIndex) => {
                     renderSubComponent(sub, compSpan, segIndex, fieldIndex, repIndex, compIndex, subIndex);
                     if (subIndex < comp.subcomponents.length - 1) {
                        const sep = document.createElement('span');
                        sep.textContent = ' & ';
                        sep.style.color = 'var(--hl7-subcomponent)';
                        compSpan.appendChild(sep);
                    }
                 });
             } else {
                 renderSubComponent(comp.subcomponents[0], compSpan, segIndex, fieldIndex, repIndex, compIndex, 0);
             }
             parentElement.appendChild(compSpan);
        };

        const renderSubComponent = (sub, parentElement, segIndex, fieldIndex, repIndex, compIndex, subIndex) => {
            const subSpan = document.createElement('span');
            subSpan.className = 'subcomponent inline-block cursor-pointer hover:bg-yellow-100';
            subSpan.textContent = sub.value;
            subSpan.dataset.segIndex = segIndex;
            subSpan.dataset.fieldIndex = fieldIndex;
            subSpan.dataset.repIndex = repIndex;
            subSpan.dataset.compIndex = compIndex;
            subSpan.dataset.subcompIndex = subIndex;
            parentElement.appendChild(subSpan);
        };

        const updateDetailsPanel = (element) => {
            if (!element) {
                detailsContent.classList.add('hidden');
                detailsPlaceholder.classList.remove('hidden');
                return;
            }

            const { segIndex, fieldIndex, repIndex, compIndex, subcompIndex } = element.dataset;
            let path = '';
            let description = 'N/A';
            let dataObject;

            const segment = parsedMessage.segments[segIndex];
            const segmentInfo = hl7Dictionary[segment.name] || {};

            path = segment.name;

            if (fieldIndex !== undefined) {
                const fieldInfo = (segmentInfo.fields && segmentInfo.fields[fieldIndex]) || "Unknown Field";
                path += `-${fieldIndex}`;
                description = fieldInfo;
                const field = segment.fields[fieldIndex];
                const repetition = field.repetitions[repIndex || 0];
                if (compIndex !== undefined) {
                    path += `.${parseInt(compIndex) + 1}`;
                    const component = repetition.components[compIndex];
                    if (subcompIndex !== undefined) {
                        path += `.${parseInt(subcompIndex) + 1}`;
                        dataObject = component.subcomponents[subcompIndex];
                        description += ` (Sub-component ${parseInt(subcompIndex) + 1})`;
                    } else {
                        dataObject = component;
                        description += ` (Component ${parseInt(compIndex) + 1})`;
                    }
                } else {
                    dataObject = repetition;
                }
            } else {
                description = segmentInfo.desc || "Unknown Segment";
                dataObject = { value: segment.fields.map(f => f.value).join(parsedMessage.delimiters.fieldSep) };
            }
            
            detailPath.textContent = path;
            detailDescription.textContent = description;
            detailValue.value = dataObject.value || '';
            originalFieldValue = dataObject.value || '';
            applyChangesBtn.disabled = true;
            undoChangesBtn.disabled = true;
            
            // Show component/subcomponent breakdown
            componentsContainer.classList.add('hidden');
            subcomponentsContainer.classList.add('hidden');
            
            const field = segment.fields[fieldIndex];
            if(field) {
                const repetition = field.repetitions[repIndex || 0];
                if (repetition && repetition.components.length > 1) {
                    componentsContainer.classList.remove('hidden');
                    componentsList.innerHTML = '';
                    repetition.components.forEach((comp, cIndex) => {
                         const compDetailDiv = createDetailItem('Component', cIndex + 1, comp.value, { ...element.dataset, compIndex: cIndex, subcompIndex: undefined });
                         componentsList.appendChild(compDetailDiv);
                    });
                }
                const component = repetition.components[compIndex];
                if(component && component.subcomponents.length > 1) {
                    subcomponentsContainer.classList.remove('hidden');
                    subcomponentsList.innerHTML = '';
                    component.subcomponents.forEach((sub, sIndex) => {
                        const subDetailDiv = createDetailItem('Sub-comp.', sIndex + 1, sub.value, { ...element.dataset, subcompIndex: sIndex });
                        subcomponentsList.appendChild(subDetailDiv);
                    });
                }
            }


            detailsPlaceholder.classList.add('hidden');
            detailsContent.classList.remove('hidden');
        };

        function createDetailItem(label, index, value, dataset) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'flex items-center text-xs p-1 rounded hover:bg-slate-100 cursor-pointer';
            Object.keys(dataset).forEach(key => itemDiv.dataset[key] = dataset[key]);
            
            itemDiv.innerHTML = `
                <span class="font-semibold text-slate-500 w-20">${label} ${index}:</span>
                <span class="font-mono text-slate-700">${value}</span>
            `;
            return itemDiv;
        }

        // --- Data Update and Sync Logic ---
        const updateDataFromDetails = () => {
            if (!selectedElement) return;

            const { segIndex, fieldIndex, repIndex, compIndex, subcompIndex } = selectedElement.dataset;
            const newValue = detailValue.value;
            
            let dataObject;
            
            const segment = parsedMessage.segments[segIndex];
            const field = segment.fields[fieldIndex];

            // Handle simple fields like MSH-2 that don't have full structure
            if (!field.repetitions) {
                if (field.value !== newValue) {
                    field.value = newValue;
                } else {
                    return; // No change
                }
            } else {
                 const repetition = field.repetitions[repIndex || 0];
                 const component = repetition.components[compIndex];
                
                if (subcompIndex !== undefined) {
                    dataObject = component.subcomponents[subcompIndex];
                } else if (compIndex !== undefined) {
                    dataObject = component;
                } else if (fieldIndex !== undefined) {
                    dataObject = repetition;
                } else {
                    // Not editable at segment level for now
                    return;
                }

                if (dataObject.value === newValue) return; // No change

                dataObject.value = newValue;
            }


            // Rebuild parent structures
            const { componentSep, subcomponentSep, repetitionSep } = parsedMessage.delimiters;
            
            if (field.repetitions) {
                const repetition = field.repetitions[repIndex || 0];
                const component = repetition.components[compIndex];
                if (subcompIndex !== undefined) {
                    component.value = component.subcomponents.map(s => s.value).join(subcomponentSep);
                }
                if (compIndex !== undefined) {
                    repetition.value = repetition.components.map(c => c.value).join(componentSep);
                }
                if (fieldIndex !== undefined) {
                    field.value = field.repetitions.map(r => r.value).join(repetitionSep);
                }
            }


            // Re-render views
            renderStructuredView();
            renderRawView();
            regenerateRawInput();
            
            // Re-select the element
            let selector = `[data-seg-index="${segIndex}"][data-field-index="${fieldIndex}"][data-rep-index="${repIndex || 0}"]`;
            if (compIndex !== undefined) selector += `[data-comp-index="${compIndex}"]`;
            if (subcompIndex !== undefined) selector += `[data-subcomp-index="${subcompIndex}"]`;

            const newElement = structuredView.querySelector(selector);
            
            if (newElement) {
                setSelected(newElement, 'details');
            }
        };

        const regenerateRawInput = () => {
            if (!parsedMessage) return;
            const { fieldSep } = parsedMessage.delimiters;
            const rawMessage = parsedMessage.segments.map(segment => {
                return segment.fields.map((field, index) => {
                     if (segment.name === 'MSH' && index === 1) return parsedMessage.delimiters.componentSep + parsedMessage.delimiters.repetitionSep + parsedMessage.delimiters.escapeChar + parsedMessage.delimiters.subcomponentSep;
                    return field.value;
                }).join(fieldSep);
            }).join('\r');
            hl7Input.value = rawMessage;
        };

        // --- Highlighting and Selection ---
        let highlightTimeout;
        const setHighlight = (element) => {
            clearTimeout(highlightTimeout);
            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
            if(element) {
                element.classList.add('highlight');
                 highlightTimeout = setTimeout(() => {
                    element.classList.remove('highlight');
                 }, 2000);
            }
        };
        
        const setSelected = (element, sourceView = 'structured') => {
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            if (!element) {
                selectedElement = null;
                updateDetailsPanel(null);
                return;
            }

            // The 'master' element is always from the structured view for consistency
            const structuredElement = structuredView.contains(element) ? element : structuredView.querySelector(`[data-seg-index="${element.dataset.segIndex}"][data-field-index="${element.dataset.fieldIndex}"]`);

            if (!structuredElement) return;

            selectedElement = structuredElement;
            updateDetailsPanel(structuredElement);

            // Highlight in structured view
            structuredElement.classList.add('selected');
            
            // Find the most specific field element to be safe
            const fieldElement = structuredElement.closest('.field');
            if(fieldElement) fieldElement.classList.add('selected');


            // Find and highlight in raw view
            const { segIndex, fieldIndex } = structuredElement.dataset;
            const rawElement = rawViewDisplay.querySelector(`[data-seg-index="${segIndex}"][data-field-index="${fieldIndex}"]`);
            if (rawElement) {
                rawElement.classList.add('selected');
            }

            // Scroll structured view if the click came from raw view
            if (sourceView === 'raw') {
                const targetToScroll = fieldElement || structuredElement;
                targetToScroll.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };


        // --- Event Handlers ---
        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        };

        const handleParsing = () => {
            const message = hl7Input.value;
            if (!message.trim()) {
                clearBtn.click();
                return;
            }
            parsedMessage = parseHL7(message);
            if (parsedMessage) {
                renderRawView();
                renderStructuredView();
                exportBtn.disabled = false;
                setSelected(null);
            } else {
                exportBtn.disabled = true;
            }
        };

        hl7Input.addEventListener('input', debounce(handleParsing, 300));

        clearBtn.addEventListener('click', () => {
            hl7Input.value = '';
            parsedMessage = null;
            structuredView.innerHTML = '';
            rawViewDisplay.innerHTML = '';
            rawViewDisplay.classList.add('hidden');
            hl7Input.classList.remove('hidden');
            placeholder.classList.remove('hidden');
            setSelected(null);
            exportBtn.disabled = true;
        });
        
        openFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    hl7Input.value = e.target.result;
                    handleParsing();
                };
                reader.readAsText(file);
            }
        });
        
        // Drag and Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false);
        });
        dropZone.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const file = dt.files[0];
            if (file) {
                 const reader = new FileReader();
                reader.onload = (e) => {
                    hl7Input.value = e.target.result;
                    handleParsing();
                };
                reader.readAsText(file);
            }
        });

        rawViewDisplay.addEventListener('click', (e) => {
            const targetElement = e.target.closest('[data-field-index]');
            if(targetElement) {
                const { segIndex, fieldIndex } = targetElement.dataset;
                const structuredFieldElement = structuredView.querySelector(`.field[data-seg-index="${segIndex}"][data-field-index="${fieldIndex}"]`);
                if (structuredFieldElement) {
                     // We select the field div, but the logic can drill down if needed
                    setSelected(structuredFieldElement, 'raw');
                }
            }
        });

        // Event delegation for structured view and details panel
        document.body.addEventListener('click', (e) => {
            // Prevent raw view clicks from being caught here and deselecting
            if (rawViewDisplay.contains(e.target)) return;

            const targetElement = e.target.closest('[data-seg-index]');

            if (targetElement && (structuredView.contains(targetElement) || detailsPanel.contains(targetElement))) {
                setSelected(targetElement);
            } else if (!detailsPanel.contains(e.target)) {
                 // Clicked outside, deselect
                setSelected(null);
            }
        });

        document.body.addEventListener('mouseover', (e) => {
            const targetElement = e.target.closest('[data-seg-index]');
            if (targetElement && (structuredView.contains(targetElement) || detailsPanel.contains(targetElement))) {
                setHighlight(targetElement);
            }
        });
        
        detailValue.addEventListener('input', () => {
            if (!selectedElement) return;
            const isChanged = detailValue.value !== originalFieldValue;
            applyChangesBtn.disabled = !isChanged;
            undoChangesBtn.disabled = !isChanged;
        });

        undoChangesBtn.addEventListener('click', () => {
            if (originalFieldValue !== null) {
                detailValue.value = originalFieldValue;
                applyChangesBtn.disabled = true;
                undoChangesBtn.disabled = true;
            }
        });

        applyChangesBtn.addEventListener('click', () => {
            if (!selectedElement || applyChangesBtn.disabled) return;
            updateDataFromDetails();
            // After applying, the new value becomes the original for the next edit session on this field
            originalFieldValue = detailValue.value; 
            applyChangesBtn.disabled = true;
            undoChangesBtn.disabled = true;
        });


        exportBtn.addEventListener('click', () => {
            if (!parsedMessage) return;
            regenerateRawInput();
            const messageText = hl7Input.value;
            const blob = new Blob([messageText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `edited-message-${new Date().toISOString()}.7`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Keyboard navigation
        structuredView.addEventListener('keydown', (e) => {
            if (!selectedElement) return;

            // Basic up/down navigation for now
            // A more complex implementation would traverse the grid properly
            const allElements = Array.from(structuredView.querySelectorAll('.subcomponent, .component, .field'));
            const currentIndex = allElements.indexOf(selectedElement);

            let nextIndex = -1;
            if (e.key === 'ArrowDown' || e.key === 'Tab') {
                e.preventDefault();
                if (currentIndex < allElements.length - 1) {
                    nextIndex = currentIndex + 1;
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (currentIndex > 0) {
                    nextIndex = currentIndex - 1;
                }
            }

            if (nextIndex !== -1) {
                const nextElement = allElements[nextIndex];
                setSelected(nextElement);
                nextElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        });
        
        // Set focus to allow keydown events
        structuredView.setAttribute('tabindex', 0);


        // --- Initial Load ---
        const init = () => {
            loadDictionary();
            exportBtn.disabled = true;
        };

        init();
    });
    </script>
</body>
</html>

